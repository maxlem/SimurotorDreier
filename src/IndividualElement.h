/*
 * IndividualElement.h
 *
 *  Created on: 14-Jul-2008
 *      Author: malem303
 */

#ifndef INDIVIDUALELEMENT_H_
#define INDIVIDUALELEMENT_H_
#include <math.h>
#include <boost/numeric/ublas/vector.hpp>
#include <boost/numeric/ublas/matrix.hpp>
#include "AtmosphericConditions.h"
#include "Constants.h"
using namespace boost::numeric::ublas;



class IndividualElement {
protected:

	/*! \f$ \mathbf{d}_{IELA-Ref} \f$ */
    vector<double> distanceIELAFromReferenceAxes;

    /*! \f$ \mathbf{T}_{IERA-IELA}\left(\theta_{x},\theta_{y},\theta_{z}\right) \f$ */
    vector<double> rotationAnglesIERAFromIELA;

    /*! \f$ \mathbf{v}_{a|IELA} \f$ */
    vector<double> aerodynamicVelocityIELA;

    /*! \f$ \mathbf{\omega}_{a|IELA} \f$ */
    vector<double> aerodynamicAngularVelocityIELA;

    /*! \f$ \mathbf{v}_{wash|IELA} \f$ */
    vector<double> washVelocityIELA;

    /*! \f$ \mathbf{\omega}_{wash|IELA} \f$ */
    vector<double> washAngularVelocityIELA;

    /*! \f$ \mathbf{v}_{i|IELA} \f$ */
    vector<double> inertialVelocityIELA;

    /*! \f$ \mathbf{\omega}_{i|IELA} \f$ */
    vector<double> inertialAngularVelocityIELA;

    /*! \f$ \mathbf{f}_{IELA} \f$ */
    vector<double> forcesIELA;

    /*! \f$ \mathbf{f}_{IELA}^{\curvearrowright} \f$ */
    vector<double> momentsIELA;

    matrix<double> selfInducedWashVelocityModel;

    vector<double> computeDistanceIELAFromCenterOfGravity(IndividualElement & centerOfGravity);



public:
    /*!
     *
     * @param density the current value for \f$ \rho \f$
     * @return \f$ \mathbf{v}_{wash|IERA}=\frac{-1}{2\rho\left\Vert \mathbf{v}_{a|IERA}\right\Vert }\cdot\left[selfInducedVelocityModel\right]\cdot\mathbf{f}_{a|IERA} \f$
     */
    vector<double> computeSelfInducedWashVelocity(double density);


    /*!
     * updatePhysics step 1 (template method)
     * This function translate CoG velocities from CoG axes to this IndividualElement local axes (IELA)
     * \f$ 	\begin{array}{c}
			 \mathbf{v}_{IELA}=\mathbf{v}_{CoG}+\omega_{CoG}\times\mathbf{d}_{IELA-CoG}\\
			  \omega_{IELA}=\omega_{CoG}
			  \end{array}\f$
     * @param centerOfGravity the CoG, from with we get velocities
     */
	virtual void translateInertialVelocitiesToIELA(IndividualElement & centerOfGravity);

	/*!
	 * updatePhysics step 2
	 * \f$ \mathbf{v}_{a}=\mathbf{v}_{i}-\mathbf{v}_{wash} \f$
	 * @param density the current value for \f$ \rho \f$
	 */
	virtual void computeAerodynamicVelocities(double density);

    /*! updatePhysics step 3
     * This is the most crucial step, it is where we compute the forces and moments generated by this IndividualElement
	 * @param centerOfGravity the CoG, from with we get velocities
	 * @param density the current value for \f$ \rho \f$
	 */
    virtual void computeForcesAndMomentsAtIELA(IndividualElement & centerOfGravity, double density);

    /*! updatePhysics step 4
     * We computed forces and moment in local axes, we must translate them to CoG
     * \f$ 	\begin{array}{c}\mathbf{f}_{CoG}=\mathbf{f}_{IELA}\\
			\mathbf{f}_{CoG}^{\curvearrowright}=\mathbf{f}_{IELA}^{\curvearrowright}+\mathbf{d}_{IELA-CoG}\times\mathbf{f}_{CoG}
			\end{array}\f$
     * @param centerOfGravity the CoG, to which we add forces and moments
     */
    virtual void sumForcesAndMomentsToCenterOfGravity(IndividualElement & centerOfGravity);


    /*!
     * This is the place we update our wash velocities using our self-induced wash and external wash
     * @param density the current value for \f$ \rho \f$
     * @param externalWashVelocity \f$ \mathbf{v}_{wash} \f$ the wash generated by other parts of the aircraft
     * @param externalWashAngularVelocity \f$ \mathbf{\omega}_{wash} \f$ the angular wash (vortex) generated by other parts of the aircraft
     */
    virtual void updtateWashVelocities(double density, vector<double> externalWashVelocity, vector<double> externalWashAngularVelocity);



	/*!
	 *
	 * @param distanceIELAFromReferenceAxes \f$ \mathbf{d}_{IELA-Ref} \f$
	 * @param rotationAnglesIERAFromIELA \f$ \mathbf{d}_{IELA-Ref} \f$
	 */
    IndividualElement(matrix<double> selfInducedWashVelocityModel,  vector<double> distanceIELAFromReferenceAxes = Constants::ZERO_VEC_3, vector<double> rotationAnglesIERAFromIELA = Constants::ZERO_VEC_3);

    virtual ~IndividualElement();

	/*! This method updates the physics form earth velocities, it uses the <b> Template Method (GoF, p325)</b> design pattern,
     * algorithm steps are all virtual methods, overidable by subclasses
     *
     * @param centerOfGravity
     * @param atmosphericConditions
     */
    virtual void updatePhysics(IndividualElement & centerOfGravity, double density);

    /*!
     * The inertial velocity is the pure "geometric" velocity, ignoring the air surrounding the aircraft
     * @return \f$ \mathbf{v}_{i} \f$
     */
    virtual vector<double> getInertialVelocityIELA() const
    {
        return inertialVelocityIELA;
    }
    /*!
     * The inertial velocity is the pure "geometric" velocity, ignoring the air surrounding the aircraft
     * @param inertialVelocityIELA \f$ \mathbf{v}_{i} \f$
     */
    virtual void setInertialVelocityIELA(vector<double> inertialVelocityIELA)
    {
        this->inertialVelocityIELA = inertialVelocityIELA;
    }

    /*!
     * The inertial angular velocity is the pure "geometric" velocity, ignoring the air surrounding the aircraft
     * @return \f$ \mathbf{\omega}_{i} \f$
     */
    virtual vector<double> getInertialAngularVelocityIELA() const
    {
        return inertialAngularVelocityIELA;
    }

    /*!
     * The inertial angular velocity is the pure "geometric" velocity, ignoring the air surrounding the aircraft
     * @param inertialAngularVelocityIELA \f$ \mathbf{\omega}_{i} \f$
     */
    virtual void setInertialAngularVelocityIELA(vector<double> inertialAngularVelocityIELA)
    {
        this->inertialAngularVelocityIELA = inertialAngularVelocityIELA;
    }

    /*!
     * The wash velocity is a bit like a vortex that swirls around this IndividualElement
     * @return \f$ \mathbf{v}_{wash} \f$
     */
    virtual vector<double> getWashVelocityIELA() const
    {
        return washVelocityIELA;
    }
    /*!
     * The wash velocity is a bit like a vortex that swirls around this IndividualElement
     * @param washVelocityIELA \f$ \mathbf{v}_{wash} \f$
     */
    virtual void setWashVelocityIELA(vector<double> washVelocityIELA)
    {
        this->washVelocityIELA = washVelocityIELA;
    }

    /*!
     * The angular wash velocity is a bit like a vortex that swirls around this IndividualElement
     * @return \f$ \mathbf{\omega}_{wash} \f$
     */
    virtual vector<double> getWashAngularVelocityIELA() const
    {
        return washAngularVelocityIELA;
    }

    /*!
     * The angular wash velocity is a bit like a vortex that swirls around this IndividualElement
     * @param washAngularVelocityIELA \f$ \mathbf{\omega}_{wash} \f$
     */
    virtual void setWashAngularVelocityIELA(vector<double> washAngularVelocityIELA)
    {
        this->washAngularVelocityIELA = washAngularVelocityIELA;
    }

    /*!
     * The aerodynamic velocity is the velosity at which the IndividualElement meets the air
     * @return \f$ \mathbf{v}_{a} \f$
     */
    virtual vector<double> getAerodynamicVelocityIELA() const
    {
        return aerodynamicVelocityIELA;
    }

    /*!
     * The aerodynamic angular velocity is the angular velosity at which the IndividualElement meets the air
     * @return \f$ \mathbf{v}_{a} \f$
     */
    virtual vector<double> getAerodynamicAngularVelocityIELA() const
    {
        return aerodynamicAngularVelocityIELA;
    }

    /*!
     * @pre forces have been updated by computeForcesAndMomentsAtIELA()
     * @return \f$ \mathbf{f}_{IELA} \f$ the forces generated by this IndividualElement
     */
    virtual vector<double> getForcesIELA() const
    {
        return forcesIELA;
    }

    /*!
     * @deprecated
     * @param forcesIELA \f$ \mathbf{f}_{IELA} \f$ the forces generated by this IndividualElement
     */
    virtual void setForcesIELA(vector<double> forcesIELA)
    {
        this->forcesIELA = forcesIELA;
    }

    /*!
     * @pre moments have been updated by computeForcesAndMomentsAtIELA()
     * @return \f$ \mathbf{f}_{IELA}^{\curvearrowright} \f$ the moments generated by this IndividualElement
     */
    virtual vector<double> getMomentsIELA() const
    {
        return momentsIELA;
    }

    /*!
     * @deprecated
     * @param momentsIELA \f$ \mathbf{f}_{IELA}^{\curvearrowright} \f$ the moments generated by this IndividualElement
     */
    virtual void setMomentsIELA(vector<double> momentsIELA)
    {
        this->momentsIELA = momentsIELA;
    }

    virtual vector<double> getDistanceIELAFromReferenceAxes() const
    {
        return distanceIELAFromReferenceAxes;
    }

    /*!
     * The reference axes are the aircraft's master axis system
     * @param distanceIELAFromReferenceAxes \f$ \mathbf{d}_{IELA-Ref} \f$
     */
    virtual void setDistanceIELAFromReferenceAxes(vector<double> distanceIELAFromReferenceAxes)
    {
        this->distanceIELAFromReferenceAxes = distanceIELAFromReferenceAxes;
    }

    /*!
     * The IERA axis system share the IELA origin but is oriented in a more convenient way
     * (e.g. a vertical fin is rotated 90 deg. around the x axis)
     * @return \f$ \left(\phi,\theta,\psi\right) \f$ the rotation angles from the IELA to the IERA
     */
    virtual vector<double> getRotationAnglesIERAFromIELA() const
    {
        return rotationAnglesIERAFromIELA;
    }

    /*!
     * The IERA axis system share the IELA origin but is oriented in a more convenient way
     * (e.g. a vertical fin is rotated 90 deg. around the x axis)
     * @param rotationAnglesIERAFromIELA \f$ \left(\phi,\theta,\psi\right) \f$ the rotation angles from the IELA to the IERA
     */
    virtual void setRotationAnglesIERAFromIELA(vector<double> rotationAnglesIERAFromIELA)
    {
        this->rotationAnglesIERAFromIELA = rotationAnglesIERAFromIELA;
    }

};

#endif /* INDIVIDUALELEMENT_H_ */
